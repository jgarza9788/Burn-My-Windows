//////////////////////////////////////////////////////////////////////////////////////////
//          )                                                   (                       //
//       ( /(   (  (               )    (       (  (  (         )\ )    (  (            //
//       )\()) ))\ )(   (         (     )\ )    )\))( )\  (    (()/( (  )\))(  (        //
//      ((_)\ /((_|()\  )\ )      )\  '(()/(   ((_)()((_) )\ )  ((_)))\((_)()\ )\       //
//      | |(_|_))( ((_)_(_/(    _((_))  )(_))  _(()((_|_)_(_/(  _| |((_)(()((_|(_)      //
//      | '_ \ || | '_| ' \))  | '  \()| || |  \ V  V / | ' \)) _` / _ \ V  V (_-<      //
//      |_.__/\_,_|_| |_||_|   |_|_|_|  \_, |   \_/\_/|_|_||_|\__,_\___/\_/\_//__/      //
//                                 |__/                                                 //
//////////////////////////////////////////////////////////////////////////////////////////

// SPDX-FileCopyrightText: Justin Garza JGarza9788@gmail.com
// SPDX-License-Identifier: GPL-3.0-or-later

// The content from common.glsl is automatically prepended to each shader effect. This
// provides the standard input:

// vec2  iTexCoord:     Texture coordinates for retrieving the window input color.
// bool  uIsFullscreen: True if the window is maximized or in fullscreen mode.
// bool  uForOpening:   True if a window-open animation is ongoing, false otherwise.
// float uProgress:     A value which transitions from 0 to 1 during the animation.
// float uDuration:     The duration of the current animation in seconds.
// vec2  uSize:         The size of uTexture in pixels.
// float uPadding:      The empty area around the actual window (e.g. where the shadow
//                      is drawn). For now, this will only be set on GNOME.

// Furthermore, there are two global methods for reading the window input color and
// setting the shader output color. Both methods assume straight alpha:

// vec4 getInputColor(vec2 coords)
// void setOutputColor(vec4 outColor)

// The width of the fading effect is loaded from the settings.
uniform float uFadeWidth;
uniform float uScale;

uniform float uStarPerRow = 5.0;

vec4 uStarColor0 = vec4(0.0,1.0,0.0,1.0);
vec4 uStarColor1 = vec4(0.0,1.0,0.0,1.0);
vec4 uStarColor2 = vec4(0.0,0.0,1.0,1.0);
vec4 uStarColor3 = vec4(0.0,0.0,1.0,1.0);
vec4 uStarColor4 = vec4(0.0,1.0,1.0,1.0);
vec4 uStarColor5 = vec4(0.0,1.0,1.0,1.0);

vec3 getPosByAngle(float angle)
{
    return vec3(cos(angle), sin(angle), 0);
}

float getStar(vec2 uv, vec2 center, float npoints, float radiusMax, float radiusMin, float size, float rotation)
{
    float PI = 3.1415926;
    float starangle = 2.0 * PI / npoints; // Angle between points on the star

    // Define the positions for the outer and inner points of the star's initial angle, rotated by `rotation`
    vec3 p0 = (radiusMax * size) * getPosByAngle(rotation);             // Outer point, rotated by `rotation`
    vec3 p1 = (radiusMin * size) * getPosByAngle(starangle + rotation);  // Inner point, also rotated

    // Calculate the position of the current fragment relative to the star's center
    vec2 curPosuv = (uv - center) ;      // Center UV coordinates, then scale to fit the star size
    float curRadius = length(curPosuv);         // Radius from center, no need to scale further
    float curPosAngle = atan(curPosuv.x, curPosuv.y) - rotation; // Calculate angle and adjust by `rotation`

    // Determine the fractional position within the current star segment
    float a = fract(curPosAngle / starangle); // Fractional angle position within one segment
    if (a >= 0.5)
        a = 1.0 - a; // Ensure we are within the first half of the segment (symmetry)

    // Calculate the current point on the star segment, applying rotation
    a = a * starangle;                          // Actual angle for this position on the segment
    vec3 curPos = curRadius * getPosByAngle(a + rotation); // Final position, rotated

    // Calculate directions for edge detection using cross product
    vec3 dir0 = p1 - p0;  // Vector from outer to inner point
    vec3 dir1 = curPos - p0; // Vector from outer point to current position
    // Use cross product to determine if `curPos` is inside the star's edge
    return step(0.0, cross(dir0, dir1).z); // Returns 1.0 if inside, 0.0 if outside (solid edge)
}


vec4 getStarColor(float v,float alpha) {
  float steps[6];
  steps[0] = 0.0;
  steps[1] = 0.1666;
  steps[2] = 0.3333;
  steps[3] = 0.5;
  steps[4] = 0.6666;
  steps[5] = 0.9999;

  vec4 colors[6];
  colors[0] = uStarColor0;
  colors[1] = uStarColor1;
  colors[2] = uStarColor2;
  colors[3] = uStarColor3;
  colors[4] = uStarColor4;
  colors[5] = uStarColor5;

  colors[0].a = alpha;
  colors[1].a = alpha;
  colors[2].a = alpha;
  colors[3].a = alpha;
  colors[4].a = alpha;
  colors[5].a = alpha;

  if (v < steps[0]) {
    return colors[0];
  }

  for (int i = 0; i < 5; ++i) {
    if (v <= steps[i + 1]) {
      return mix(colors[i], colors[i + 1],
                 vec4(v - steps[i]) / (steps[i + 1] - steps[i]));
    }
  }

  return colors[5];
}

float interpolateFivePoints(float t, float v0, float v1, float v2, float v3, float v4) {
    // Clamp `t` between 0.0 and 1.0
    t = clamp(t, 0.0, 1.0);

    // Scale `t` to determine the current segment (0-4 range)
    float scaledT = t * 4.0;
    int segment = int(floor(scaledT)); // Segment index (0 to 3)
    float localT = fract(scaledT);      // Position within the segment (0.0 to 1.0)

    // Interpolate between the values based on the segment
    if (segment == 0) {
        return mix(v0, v1, localT);
    } else if (segment == 1) {
        return mix(v1, v2, localT);
    } else if (segment == 2) {
        return mix(v2, v3, localT);
    } else {
        return mix(v3, v4, localT);
    }
}

float starSize(float t,float max_size,float power)
{
  float s = -1 * pow((t-0.5)/(0.5),power)+1;
  s = clamp(s,0.0,1.0) * max_size;
  return s;
}



float eightBitScale(float progress)
{
    float scale = 1.0;
    if (progress <= 0.1)
    {
      scale = 0.25;
    }
    else if (progress <= 0.2)
    {
      scale = 0.5;
    }
    else if (progress <= 0.3)
    {
      scale = 0.25;
    }
    else if (progress <= 0.4)
    {
      scale = 0.5;
    }
    else if (progress <= 0.5)
    {
      scale = 0.25;
    }
    else if (progress <= 0.6)
    {
      scale = 0.5;
    }
    else if (progress <= 0.7)
    {
      scale = 1.0;
    }
    else if (progress <= 0.8)
    {
      scale = 0.25;
    }
    else if (progress <= 0.9)
    {
      scale = 0.5;
    }
    return scale;
}

void main() {


  float progress = uForOpening ? 1.0 - uProgress : uProgress;



  float scale = easeInQuart( progress );

  // Put texture coordinate origin to center of window.
  vec2 coords = iTexCoord.st * 2.0 - 1.0;

  // Scale image texture with progress.
  coords /= mix(1.0, 0.0, scale);

  // scale from center
  coords = coords * 0.5 + 0.5;

  //get image using the coords
  vec4 oColor = getInputColor(coords);


  float aspect = uSize.x / uSize.y;
  vec2 uv = vec2(iTexCoord.s - 0.5,iTexCoord.t) * vec2(aspect, 1.0);


  // oColor += star * vec4(1.0,1.0,1.0,1.0);
  float star = 0.0;
  /*
  for (int y = 0; y < 3; y++)
  {
    // float yprog = mix( y*-1.0 , 1.0 + ((y+1.0)*1.0), progress);
    float spread = y*0.33;
    float yprog = mix( 0.0 - spread , 1.0+(1.0-spread) , progress);
    yprog =  clamp(yprog,0.0001,0.999);

    for (int x = 0; x < uStarPerRow; x++) 
    {
      star = getStar(
          uv, 
          vec2( sin(progress * 6.28 + (x*(6.28/uStarPerRow))) * aspect * -0.33, yprog), //position (x, y)
          5.0, //nPoints
          0.5, //radiusMax
          0.25, //radiusMin
          starSize(yprog,0.25,4.0), //Size   
          3.14 //rotation
          );
      oColor = alphaOver(oColor,getStarColor(yprog,star));
    }
  }
  */

  star = 0.0;
  for (int x = 0; x < 5; x++) 
  {

    vec2 h = hash12(x);
    float y = mix(0.0 - h.y, 1.0 + (1.0-h.y),progress);
    // y =  clamp(y,0.0001,0.999);

    star = getStar(
        uv, 
        vec2( h.x * 2.0 - 1.0 * 0.33, y), //position (x, y)
        4.0, //nPoints
        0.5, //radiusMax
        0.125, //radiusMin
        starSize(y,0.25,4.0), //Size   
        progress * 6.28 * 3.0 //rotation
        );
    oColor = alphaOver(oColor, vec4(1.0,1.0,1.0,star));
  }



  // oColor = vec4( iTexCoord.s, iTexCoord.t, 0.0 ,1.0 ) + (star * vec4(1.0,1.0,1.0,1.0));

  setOutputColor(oColor);

  

}